#!/usr/bin/env python3

"""
Main entry point for starting a training job.
"""

import os
import sys
import argparse
import subprocess
import shutil
import logging
import logging.config

import numpy as np

env_types = [
    'test',
    'append-still',
    'append-still-easy',
    'append-spawn',
    'prune-still',
    'prune-spawn',
    'navigate',
]

parser = argparse.ArgumentParser(description="""
    Run agent training using proximal policy optimization.

    This will set up the data/log directories, optionally install any needed
    dependencies, start tensorboard, configure loggers, and start the actual
    training loop. If the data directory already exists, it will prompt for
    whether the existing data should be overwritten or appended. The latter
    allows for training to be restarted if interrupted.
    """)
parser.add_argument('data_dir', nargs='?',
    help="the directory in which to store this run's data")
parser.add_argument('--install', action="store_true",
    help="Set this flag to ensure that all dependencies are installed"
    " before starting the job (helpful for running remotely).")
parser.add_argument('--shutdown', action="store_true",
    help="Shut down the system when the job is complete"
    "(helpful for running remotely).")
parser.add_argument('--port', default=6006, type=int,
    help="Port on which to run tensorboard.")
parser.add_argument('--impact-penalty', default=0.0, type=float)
parser.add_argument('--env-type', choices=env_types)
parser.add_argument('--algo', default='ppo', choices=(
    'ppo',
    'dqn',
    'ppo-tf',
    'ppo-rr',
    'ppo-eval',
    'ensemble',
    'aup'))
parser.add_argument('--config', default='ppo', choices=('ppo', 'aup', 'aupp', 'naive'))
parser.add_argument('--z', default=1.0)
parser.add_argument('--envn', default=1)
parser.add_argument('--run_suite', action='store_true')
args = parser.parse_args()

# Setup the directories

safety_dir = os.path.realpath(os.path.join(__file__, '../'))
active_job_file = os.path.join(safety_dir, 'active_job.txt')
sys.path.insert(1, safety_dir)  # ensure current directory is on the path
os.chdir(safety_dir)

# If the run name isn't suppied, get it from 'active_job.txt'
# This is basically just used to restart after crashes.
if not args.data_dir:
    if os.path.exists(active_job_file):
        with open(active_job_file) as f:
            data_dir = f.read().strip()
        print("Setting `data_dir` from `active_job.txt`")
    else:
        print("No run name was supplied. Aborting.")
        exit()
else:
    data_dir = os.path.realpath(args.data_dir)
with open(active_job_file, 'w') as f:
    f.write(data_dir)
job_name = os.path.split(data_dir)[1]


if os.path.exists(data_dir) and args.data_dir is not None:
    print("The directory '%s' already exists. "
          "Would you like to overwrite the old data, append to it, or abort?" %
          data_dir)
    response = None
    response = 'overwrite' if job_name.startswith('tmp') else None
    while response not in ('overwrite', 'append', 'abort'):
        response = input("(overwrite / append / abort) > ")
    if response == 'overwrite':
        print("Overwriting old data.")
        shutil.rmtree(data_dir)
    elif response == 'abort':
        print("Aborting.")
        exit()

# response = 'append'
os.makedirs(data_dir, exist_ok=True)
logfile = os.path.join(data_dir, 'training.log')

# Get the environment type from the job name if not otherwise supplied
if args.env_type:
    env_type = args.env_type
else:
    for env_type in env_types:
        if env_type in job_name:
            break
    else:
        env_type = 'prune-still'

assert env_type in env_types

# Setup logging

if not os.path.exists(logfile):
    open(logfile, 'w').close()  # write an empty file
logging.config.dictConfig({
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'simple': {
            'format': '{levelname:8s} {message}',
            'style': '{',
        },
        'dated': {
            'format': '{asctime} {levelname} ({filename}:{lineno}) {message}',
            'style': '{',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'stream': 'ext://sys.stdout',
            'formatter': 'simple',
        },
        'logfile': {
            'class': 'logging.FileHandler',
            'level': 'INFO',
            'formatter': 'dated',
            'filename': logfile,
        }
    },
    'loggers': {
        'training': {
            'level': 'INFO',
            'propagate': False,
            'handlers': ['console', 'logfile'],
        },
        'safelife': {
            'level': 'INFO',
            'propagate': False,
            'handlers': ['console', 'logfile'],
        }
    },
    'root': {
        'level': 'WARNING',
        'handlers': ['console', 'logfile'],
    }
})

# Install dependencies if they aren't already there

if args.install:
    reqs_file = os.path.join(safety_dir, "requirements.txt")
    subprocess.run("sudo apt-get install ffmpeg --yes".split())
    subprocess.run(["sudo", "pip3", "install", "-r", reqs_file])
# By making the build lib the same as the base folder, the extension
# should just get built into the source directory.
subprocess.run([
    "python3", os.path.join(safety_dir, "setup.py"),
    "build_ext", "--build-lib", safety_dir
])


# Start tensorboard

if args.port:
    tb_proc = subprocess.Popen([
        "python3",
        "-m",
        "tensorboard.main",
        "--logdir",
        job_name + ':' + data_dir,
        '--port', str(args.port)])


# Start training!
def spawn_loader(name):
    # When training in spawn environments, we first pre-train in the static
    # environments for a couple million time steps. This just provides more
    # opportunities for rewards so makes the initial training easier.
    from safelife.file_finder import SafeLifeLevelIterator
    from safelife.safelife_env import SafeLifeEnv

    loader1 = SafeLifeLevelIterator('safelife/levels/random/append-still-easy'.format(name))
    # loader2 = SafeLifeLevelIterator('8env_{}-spawn'.format(name),
    loader2 = SafeLifeLevelIterator('safelife/levels/random/append-spawn'.format(name))
    t0 = 1.5e6 if name == 'prune' else 2.0e6
    while True:
        if SafeLifeEnv.global_counter.num_steps < 0:
            yield next(loader1)
        else:
            yield next(loader2)


def spawn_loader_aup(name):
    # When training in spawn environments, we first pre-train in the static
    # environments for a couple million time steps. This just provides more
    # opportunities for rewards so makes the initial training easier.
    from safelife.file_finder import SafeLifeLevelIterator
    from safelife.safelife_env import SafeLifeEnv

    loader1 = SafeLifeLevelIterator('safelife/levels/random/append-still-easy'.format(name))
    loader2 = SafeLifeLevelIterator('8env_{}-spawn'.format(name),
                                                   distinct_levels=8,
                                                   total_levels=-1)
    trand = 0
    tstill = 1.0e6
    tspawn = 3.0e6
    while True:
        count = SafeLifeEnv.global_counter.num_steps
        if count >= trand and count < tstill:
            p = np.random.randint(2, size=1)[0]
            yield next(loader1) if p else next(loader2)

        elif count >= tstill and count < tspawn:
            yield next(loader1)
        
        elif count >= tspawn:
            yield next(loader2)
        else:
            raise ValueError


try:
    from training.env_factory import linear_schedule, safelife_env_factory
    from safelife.file_finder import SafeLifeLevelIterator

    for penalty in [args.impact_penalty]:
        subdir = os.path.join(data_dir, "penalty_{:0.2f}".format(penalty))
        os.makedirs(subdir, exist_ok=True)

        if args.algo == 'ppo-tf':
            from training.tf_ppo import SummaryWriter
        else:
            from tensorboardX import SummaryWriter

        if env_type == 'test':
            t_penalty = [1.0e6, 2.0e6]
            t_performance = [1.0e6, 2.0e6]
            training_levels = 'puzzles/14 - Blinky maze.npz'
            test_levels = 'puzzles/14 - Blinky maze.npz'
            level_iterator = SafeLifeLevelIterator(training_levels,
                    distinct_levels=1,
                    total_levels=-1)

            # test_levels = 'benchmarks/v1.0/append-still.npz'

        if env_type == 'append-still':
            t_penalty = [1.0e6, 2.0e6]
            t_performance = [1.0e6, 2.0e6]
            training_levels = '8env_append-still-hard'
            nlevels = 8
            if args.algo == 'ppo-eval':
                training_levels = '8env_append-still-hard/8env_append-still-hard-{}.npz'.format(
                        args.envn)
                nlevels = 1

            test_levels = training_levels
            level_iterator = SafeLifeLevelIterator(training_levels,
                                                  distinct_levels=nlevels,
                                                  total_levels=-1)
        if env_type == 'append-still-easy':
            t_penalty = [1.0e6, 2.0e6]
            t_performance = [1.0e6, 2.0e6]
            training_levels = 'level_sets/append-still-easy/8env/batch1/'
            nlevels = 8
            if args.algo == 'ppo-eval':
                training_levels = '8env_append-still-easy/8env_append-stll-easy-{}.npz'.format(
                        args.envn)
                nlevels = 1
            test_levels = training_levels
            level_iterator = SafeLifeLevelIterator(training_levels,
                    distinct_levels=nlevels,
                    total_levels=-1)


            # test_levels = 'benchmarks/v1.0/append-still.npz'

        elif env_type == 'prune-still':
            t_penalty = [0.5e6, 1.5e6]
            t_performance = [0.5e6, 1.5e6]
            training_levels = '8env_prune-still-easy'
            nlevels = 8
            if args.algo == 'ppo-eval':
                training_levels = '8env_prune-still-easy/8env_prune-still-easy-{}.npz'.format(
                        args.envn)
                nlevels = 1
            test_levels = training_levels
            level_iterator = SafeLifeLevelIterator(training_levels,
                                                   distinct_levels=nlevels,
                                                   total_levels=-1)

        elif env_type == 'append-spawn':
            t_penalty = [2.0e6, 3.5e6]
            t_performance = [1.0e6, 2.0e6]
            level_iterator = spawn_loader('append')
            nlevels = 8
            if args.algo == 'ppo-eval':
                training_levels = '8env_append-spawn/8env_append_spawn-{}.npz'.format(
                        args.envn)
                nlevels = 1
                level_iterator = SafeLifeLevelIterator(training_levels,
                        distinct_levels=nlevels,
                        total_levels=-1)
            test_levels = training_levels
            #test_levels = 'benchmarks/v1.0/append-spawn.npz'

        elif env_type == 'prune-spawn':
            t_penalty = [1.5e6, 2.5e6]
            t_performance = [0.5e6, 1.5e6]
            level_iterator = spawn_loader('append')
            test_levels = 'benchmarks/v1.0/append-spawn.npz'

        elif env_type == 'navigate':
            t_penalty = [1.0e6, 2.0e6]
            t_performance = [1.0e6, 2.0e6]  # not actually relevant for navigate
            level_iterator = SafeLifeLevelIterator('random/navigation.yaml',
                                                   distinct_levels=4,
                                                   total_levels=-1)
            test_levels = 'benchmarks/v1.0/navigation.npz'
        else:
            print("Unexpected environment type '{}'".format(env_type))

        summary_writer = SummaryWriter(subdir)

        training_envs = safelife_env_factory(
            logdir=subdir, summary_writer=summary_writer, num_envs=16,
            impact_penalty=linear_schedule(t_penalty, [0, penalty]),
            min_performance=linear_schedule(t_performance, [0.01, 0.3]),
            #min_performance=linear_schedule(t_performance, [0.3, 0.3]),
            level_iterator=level_iterator,
        )
        testing_envs = safelife_env_factory(
            logdir=subdir, summary_writer=summary_writer, num_envs=8, testing=True,
            level_iterator=SafeLifeLevelIterator(
                test_levels, distinct_levels=8, total_levels=-1)
        )

        if args.algo == 'ppo-tf':
            import tensorflow as tf
            from training.tf_safelife_ppo import SafeLifePPO
            tf.reset_default_graph()

            algo = SafeLifePPO(
                envs=training_envs,
                logdir=subdir, summary_writer=summary_writer)
            algo.train(6e6)

        elif args.algo == 'ensemble':
            from training.models import SafeLifePolicyNetwork
            from training.ppo_ensemble import PPO_AUP
            n_rfns = 2
            obs_shape = training_envs[0].observation_space.shape
            model = SafeLifePolicyNetwork(obs_shape)
            models_aup = [SafeLifePolicyNetwork(obs_shape) for _ in range(n_rfns)]
            algo = PPO_AUP(
                model,
                models_aup,
                env_type,
                n_rfns=n_rfns,
                training_envs=training_envs,
                testing_envs=testing_envs,
                logdir=subdir,
                summary_writer=summary_writer)
            algo.train(5e6)
        
        elif args.algo == 'ppo-rr':
            from training.models import SafeLifePolicyNetwork
            from training.ppo import PPO
            obs_shape = training_envs[0].observation_space.shape
            model = SafeLifePolicyNetwork(obs_shape)
            model_aup = SafeLifePolicyNetwork(obs_shape)
            
            if 0:
                algo_val2 = PPO(
                        None, model, model_aup, env_type,
                        training_envs=training_envs,
                        testing_envs=testing_envs,
                        z_dim=8,
                        agent_index=1,
                        logdir=subdir, summary_writer=summary_writer)
                algo_val2.train(1e6)
            
            algo = PPO(
                    None, model, model_aup, env_type,
                    training_envs=training_envs,
                    testing_envs=testing_envs,
                    z_dim=int(args.z),
                    name=args.config,
                    agent_index=1,
                    logdir=subdir, summary_writer=summary_writer)
            algo.train(6e6)

        elif args.algo == 'aup':
            from training.models import SafeLifePolicyNetwork
            from training.aux_training_ppo import PPO_AUX
            from training.aup_training_ppo import PPO_AUP

            obs_shape = training_envs[0].observation_space.shape
            train_model_aux = SafeLifePolicyNetwork(obs_shape)
            train_model_aup = SafeLifePolicyNetwork(obs_shape)

            aux_model = PPO_AUX(
                    train_model_aux, env_type,
                    training_envs=training_envs,
                    testing_envs=testing_envs,
                    z_dim=int(args.z),
                    logdir=subdir, summary_writer=summary_writer)
            aux_model.train(1e6)   

            aup_model = PPO_AUP(
                    train_model_aup, aux_model, env_type,
                    training_envs=training_envs,
                    testing_envs=testing_envs,
                    z_dim=int(args.z),
                    logdir=subdir, summary_writer=summary_writer)
            aup_model.train(4e6)   

        elif args.algo == 'ppo-eval':
            from training.models import SafeLifePolicyNetwork
            from training.ppo_eval import PPO_eval
            obs_shape = training_envs[0].observation_space.shape
            model = SafeLifePolicyNetwork(obs_shape)
            model_aup = SafeLifePolicyNetwork(obs_shape)

            algo = PPO_eval(
                    None, model, model_aup, env_type,
                    training_envs=training_envs,
                    testing_envs=testing_envs,
                    z_dim=1,
                    name=args.config,
                    level_idx=args.envn,
                    agent_index=1,
                    logdir=subdir, summary_writer=summary_writer)
            algo.test()


        elif args.algo == 'dqn':
            from training.models import SafeLifeQNetwork
            from training.dqn import DQN

            obs_shape = training_envs[0].observation_space.shape
            train_model_aux = SafeLifeQNetwork(obs_shape)
            target_model_aux = SafeLifeQNetwork(obs_shape)
            train_model_aup = SafeLifeQNetwork(obs_shape)
            target_model_aup = SafeLifeQNetwork(obs_shape)

            algo = DQN(
                train_model_aux, target_model_aux,
                train_model_aup, target_model_aup,
                env_type=env_type,
                z_dim=1,
                rand_proj=True,
                training_envs=training_envs,
                testing_envs=testing_envs,
                logdir=subdir, summary_writer=summary_writer)
            algo.train(2e6)

                                  
except Exception:
    logging.exception("Ran into an unexpected error. Aborting training.")
finally:
    if args.port:
        tb_proc.kill()
    if os.path.exists(active_job_file):
        os.remove(active_job_file)
    if args.shutdown:
        # Shutdown in 3 minutes.
        # Enough time to recover if it crashed at the start.
        subprocess.run("sudo shutdown +3".split())
        print("Shutdown commenced. Exiting to bash.")
        subprocess.run(["bash", "-il"])
